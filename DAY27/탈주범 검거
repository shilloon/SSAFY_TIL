from collections import deque

def bfs(struct_dict, tunnel, L, R, C, N, M):

    opposite = {
        (-1, 0) : (1, 0),
        (1, 0) : (-1, 0),
        (0, -1) : (0, 1),
        (0, 1): (0, -1)
    }

    visited = [[False] * M for _ in range(N)]
    q = deque()
    q.append((R, C, 1))
    visited[R][C] = True

    while q:
        r, c, t = q.popleft()
        if t >= L:
            continue

        cur_struct = tunnel[r][c]
        for dy, dx in struct_dict[cur_struct]:
            ny = r + dy
            nx = c + dx

            if 0 <= ny < N  and 0 <= nx < M and tunnel[ny][nx] != 0:
                next_struct = tunnel[ny][nx]
                if opposite[(dy, dx)] in struct_dict[next_struct]:
                    if not visited[ny][nx]:
                        visited[ny][nx] = True
                        q.append((ny, nx, t+1))

    count = 0
    for i in range(N):
        for j in range(M):
            if visited[i][j]:
                count += 1

    return count


T = int(input())
for tc in range(1, T+1):
    N, M, R, C, L = map(int, input().split())
    struct_dict = {
        1 : [(-1, 0), (1, 0), (0, -1), (0, 1)],
        2 : [(-1, 0), (1, 0)],
        3 : [(0, -1), (0, 1)],
        4 : [(-1, 0), (0, 1)],
        5 : [(1, 0), (0, 1)],
        6 : [(1, 0), (0, -1)],
        7 : [(-1, 0), (0, -1)]
    }
    tunnel_matrix = [list(map(int, input().split())) for _ in range(N)]

    result = bfs(struct_dict, tunnel_matrix, L, R, C, N, M)

    print(f'#{tc} {result}')
