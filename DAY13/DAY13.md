# 정렬

## 버블 정렬

인접한 값들을 비교하며 위치 교환하는 방식

최악 시간복잡도 = O(n^2)
최선 시간복잡도 = O(n)

안정성 (동일한 키 값을 가지는 보존의 상대적 순서를 보존) = o
적응성 (초기 정렬 상태에 따라 속도가 바뀌는가) = o
제자리 정렬 (외부 메모리를 사용 여부)= o (외부 메모리를 안쓴다는 것)

## 선택 정렬

주어진 값들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식 ( 반복문을 돌릴 때마다 최솟값 찾아서 위치 교환하여 순서대로)

최악/최선 시간복잡도 = O(n^2)

안정성 = x  ex) [4, 2, 3, 4, 1] -> [1, 2, 3, 4, 4]  동일한 4의 위치가 바뀜
적응성 = x
제자리 정렬 = o

## 삽입 정렬 ( 데이터가 적을 때 효율적, 병합 정렬은 데이터가 많을 때)

리스트를 정렬/미정렬로 나누고, 미정렬 부분의 원소를 정렬된 부분의 올바른 위치에 삽입

초기상태: 첫번째 원소를 정렬되었다 가정을 하고 실행

정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬 되어있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입

최악 시간복잡도 = O(n^2)
최선 시간복잡도 = 오메가(n)

안정성 = o
적응성 = o
제자리 정렬 = o

## 카운팅 정렬

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
선형시간 -> 비교 기반(x)

제한 사항
정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
가장 큰 정수를 알아야함

시간 복잡도 = O(n + k(최댓값 구하는 시간까지))

안정성이 떨어지므로 확보하는 작업이 필요 (누적합 배열)

안정성  = o
적응성 = x
제자리 정렬 = x
