import heapq
import math


def dijkstra(graph, start):

    all_nodes = set(graph.keys())
    for neighbors in graph.values():
        all_nodes.update(neighbors.keys())

    distances = {node : math.inf for node in all_nodes}

    distances[start] = 0
    min_heap = []
    heapq.heappush(min_heap, [0, start])

    while min_heap:
        cur_distance, cur_vertex = heapq.heappop(min_heap)

        if distances[cur_vertex] < cur_distance: continue

        if cur_vertex not in graph : continue

        for adjacent, weight in graph[cur_vertex].items():
            distance = cur_distance + weight
            if distance < distances[adjacent]:
                distances[adjacent] = distance
                heapq.heappush(min_heap, [distance, adjacent])

    return distances


T = int(input())
for tc in range(1, T+1):
    N, M, X = map(int, input().split())

    graph = {}

    for _ in range(M):
        x, y, c = map(int, input().split())

        if x not in graph:
            graph[x] = {}

        graph[x][y] = c

    path_distance = [0] * (N+1)

    for i in range(1, N+1):
        path_list = dijkstra(graph, i)

        if i == X:
            for j in range(1, N+1):
                path_distance[j] += path_list[j]

        else:
            path_distance[i] += path_list[X]


    print(f'#{tc} {max(path_distance)}')
