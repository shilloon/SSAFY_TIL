import sys
sys.stdin = open("input.txt", "r")
import heapq
import math


def dijkstra(graph, start):

    all_nodes = set(graph.keys())
    for neighbors in graph.values():
        all_nodes.update(neighbors.keys())

    distances = {node : math.inf for node in all_nodes}

    distances[start] = 0
    min_heap = []
    heapq.heappush(min_heap, [0, start])

    while min_heap:

        cur_distance, cur_vertex = heapq.heappop(min_heap)

        if distances[cur_vertex] < cur_distance : continue

        if cur_vertex not in graph : continue

        for adjacent, weight in graph[cur_vertex].items():
            distance = cur_distance + weight
            if distance < distances[adjacent]:
                distances[adjacent] = distance
                heapq.heappush(min_heap, [distance, adjacent])

    return distances

dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]]
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    matrix = [list(map(int, input().split())) for _ in range(N)]

    graph = {}
    vertex = 0
    for i in range(N):
        for j in range(N):
            w = 0
            if vertex not in graph:
                graph[vertex] = {}

            for dx, dy in dxy:
                nx, ny = i + dx, j + dy

                if nx < 0 or ny < 0 or nx >= N or ny >= N: continue

                if matrix[i][j] < matrix[nx][ny]:
                    w = (matrix[nx][ny] - matrix[i][j]) + 1
                else:
                    w = 1

                if dx == -1:
                    graph[vertex][vertex-N] = w
                elif dx == 1:
                    graph[vertex][vertex+N] = w
                elif dy == -1:
                    graph[vertex][vertex-1] = w
                elif dy == 1:
                    graph[vertex][vertex+1] = w

            vertex += 1

    start_v = 0
    dijkstra_result = dijkstra(graph, start_v)

    print(f'#{tc} {dijkstra_result[N*N-1]}')
